她们都有自己的孩子和孙子 本讲座是关于文本检索系统的实现。 在本讲座中, 我们将讨论如何实现文本 检索方法来构建搜索引擎。 主要的挑战是管理大量的文本数据和 使查询能够非常快速地得到答复, 并响应许多查询。 这是一个典型的文本检索系统体系结构。 我们可以看到文档首先由分词器处理 获取标记单位, 例如单词。 然后, 这些单词, 或令牌, 将由 将创建索引的索引器, 该索引是 用于快速回答查询的搜索引擎。 而查询将经历类似的处理步骤。 因此, 令牌人也会被告知查询, 以便以相同的方式处理文本。 同样的词将相互匹配。 然后, 查询的表示将被提供给 Scorer, 这将使用索引快速回答用户的查询通过 给文档打分, 然后对其进行排名。 结果将提供给用户。 然后用户可以查看结果, 并向我们提供一些反馈, 可以 明确判断哪些文件是好的, 哪些文件是坏的。 或隐式反馈, 如这样的用户不必做任何额外的。 最终用户只需查看结果, 跳过一些, 并点击一些结果查看。 因此, 这些相互作用的信号可以被系统用来提高排名 准确性, 前提是查看的文档比跳过的文档更好。 因此, 搜索引擎系统可以分为三个部分。 第一部分是indexer 第二部分是Scorer 响应用户查询, 第三部分是反馈机制。 现在通常情况下, 索引器是以脱机方式完成的, 因此 您可以预先处理正确的数据和 建立库存指数, 我们将在一会儿介绍 然后, 这个数据结构可以被一个得分手的在线模块使用 " 以动态处理用户的查询并快速生成搜索结果。 反馈机制可以在线或离线完成, 具体取决于方法。 索引器和得分手的实现是非常标准的, 这是本次讲座和接下来的几首讲座的主要主题。 另一方面, 反馈机制有很多变化 这取决于使用哪种方法。 因此, 这通常是以特定的算法方式完成的。 让我们先谈谈分词器 分词是通过相同形式的规范化词汇单位, 这样语义上相似的单词就可以相互匹配。 现在, 在像英语这样的语言, 词干经常被使用和 这将把所有的屈折形式的单词映射到相同的根形式。 因此, 例如, 计算机, 计算, 和 计算都可以与词根计算匹配。 这样, 所有这些不同形式的计算都可以相互匹配。 现在通常情况下, 这是个好主意, 以增加与此查询匹配的文档的覆盖范围。 但这也并不总是有效的 因为有时计算机和计算机之间有微妙的区别 计算可能仍然表明在内容的覆盖面的差异。 但在大多数情况下, 词干似乎是有效的 当我们用其他语言 (例如中文) 标记文本时, 我们可能会 在分割文本以查找单词边界时面临一些特殊的挑战。 因为它是不明显的边界是 没有空间把他们分开 因此, 在这里, 我们当然必须使用一些特定于语言的处理技术。 一旦我们做好分词, 那么我们会索引的文本文档, 比它将 转换文档并执行一些数据结构, 以实现更快的搜索。 基本的想法是尽可能地预先计算我们所能做到的。 因此, 最常用的索引是调用倒置索引。 这已经在许多搜索引擎中使用过 以支持基本的搜索算法。 有时其他索引, 例如, 可能需要文档索引来支持反馈, 就像我说的。 而这种技术并不是真正的标准 他们根据反馈方法的不同而变化很大。 要理解为什么我们要使用倒置索引, 它将是有用的 您可以考虑如何快速响应单个术语查询。 所以, 如果你想用更多的时间来考虑这个问题, 暂停视频。 所以, 想想如何可以预先处理的文本数据, 使得 你可以快速响应只有一个字的查询 如果你想过这个问题 你可能会意识到, 最好的地方是简单地创建 与词汇中的每个术语匹配的文档列表。 这样, 您基本上可以预先构造答案。 所以, 当你看到一个术语, 你可以简单地获取随机列表的文件 并将列表返回给用户。 所以这是在这里对一个术语做出反应的最快方式。 现在反转索引的概念实际上是这样的。 我们要做一个预先构建的搜索索引, 这将允许 我们可以快速找到与特定术语匹配的所有文档。 因此, 让我们来看看这个例子。 我们这里有三份文件 这些都是你在以前的一些讲座中看到的文件。 假设我们要为这些文档创建一个倒置索引。 然后, 我们要维护一个字典, 在字典里, 我们将有一个条目对应一个词 我们将存储一些关于这个术语的基本静态统计数据。 例如, 与术语匹配的文档数, 或 代码的总数或术语的频率, 这意味着我们会记录这个词重复出现的次数。 因此, 例如, 新闻, 这个术语出现在所有三个文档中, 所以文件的数量是三。 你也可能会意识到我们需要这个文件计数, 或文件频率, 用于计算矢量空间模型中使用的一些统计数据。 你可以想想吗 那么, 什么加权启发式就需要这个计数。 好吧, 这就是想法, 对, 反向文档频率。 所以, IDF 是一个术语的属性, 我们可以在这里计算。 因此, 有了这里计算的文档, 就很容易计算出 或者在这个时候, 或者用旧的索引, 或者。 在随机的时间, 当我们看到一个查询。 现在除了这些基本的统计数据外 我们还会存储所有与新闻相匹配的文件 这些条目存储在名为 "发布" 的文件中。 因此, 在这种情况下, 它匹配三个文件和 我们在这里存储有关这三个文档的信息。 这是文档 id, 文档1和频率为1。 tf 是1对于新闻而言, 在第二个文件, 它也是 1, 等等。 因此, 从这个列表中, 我们可以得到所有的文件, 匹配的术语新闻和 我们也可以知道这些文件中的新闻频率。 所以, 如果查询只有一个单词, 新闻,那么 我们可以很容易地查找此表, 以找到条目然后 很快的去posting里,获取所有的匹配文件, 所以, 让我们来看看另一个术语。 这一次, 让我们来看看总统这个词。 这只发生在一个文档中, 文档3。 因此, 文档频率为 1, 但在本文档中发生了两次。 所以频率计数是二, 频率计数用于 一些其他可访问的方法, 我们可能会使用的频率 评估一个术语在集合中的受欢迎程度。 同样, 我们将有一个指针, 在这里的帖子, 在这种情况下, 这里只有一个条目, 因为 这个词只出现在一个文档中, 就在这里。 文档 id 为 3, 它发生了两次。 因此, 这就是倒置索引的基本思想。 其实很简单, 对吧？ 使用此结构, 我们可以轻松地获取与术语匹配的所有文档。 这将是为查询打分文档的基础。 现在有时我们也想存储这些术语的位置。 因此, 在其中许多情况下, 该术语只发生在文档中一次。 因此, 在这种情况下, 只有一个位置。 但在这种情况下, 这个词发生了两次, 所以有两个位置。 现在的位置信息是非常有用的检查是否 查询术语的匹配实际上是在一个小窗口中, 让我们说, 五个字或十个字。 或者, 两个查询术语的匹配实际上是两个词的短语。 通过使用每个位置, 可以快速检查这一切。 那么, 为什么倒置索引对快速搜索有好处呢？ 嗯, 我们刚刚讨论了使用两个答案单术语查询的可能性。 这很容易。 多术语查询呢？ 让我们先来看看布尔查询的一些特殊情况。 布尔查询基本上是这样的布尔表达式。 因此, 我希望文档中的值与术语 a 和术语 B 相匹配。 所以这是一个结合的查询。 或者我希望 web 文档与术语 a 或术语 B 匹配。 这是一个排斥的查询。 但是, 我们如何通过使用倒置索引来回答这样的查询呢？ 好吧, 如果你想一下, 这将是显而易见的, 因为我们只是获取所有 与术语 a 匹配的文档, 并获取与术语 B 匹配的所有文档。 然后只需使用交叉点回答像 A 和 B 这样的查询。 或者带联合回答查询 a 或 B。 所以这一切都很容易回答。 会很快的。 那么多术语关键字查询呢？ 我们讨论了向量空间模型, 例如, 我们将做这样的查询与文档匹配, 并生成分数。 而分数是基于汇总的术语权重。 因此, 在这种情况下, 它不是布尔查询, 但 得分实际上可以用类似的方式完成。 基本上, 它类似于分离布尔查询。 基本上, 就像 A 或 B。 我们采取的所有文件的联合, 匹配至少一个查询术语和 然后我们将聚合术语权重。 因此, 这是一般对评分文档使用倒置索引的基本思想。 我们稍后将更详细地讨论这个问题。 但现在但现在 让我们来看看为什么倒置索引是一个好主意？ 为什么它会比按顺序扫描文档更有效。 这是显而易见的方法。 您只需计算每个文档的分数, 然后就可以对它们进行排序。 这是一个简单的方法, 但 这将是非常缓慢的想象财富, 有很多文件。 如果您这样做, 则需要很长时间才能回答您的查询。 那么现在的问题是, 为什么倒置索引会更快？ 好吧, 它必须做的是文字中的单词分布。 所以, 这里有一些常见的现象, 单词分布在文本中。 有些语言独立于看似稳定的模式。 而这些模式的基本特点是以下模式。 几个词, 如常见的词, 如, the,a,or we，在文本中非常非常频繁地出现。 因此, 它们占单词出现的很大比例。 但大多数词很少会出现。 有很多词只发生过一次, 让我们说, 在文档中或在集合中一次。 而且这样的情况很多。 有一个常见的事实是，在一个语料库最高频出现的那个单词 在另一个语料库中很少出现 这意味着, 尽管一般现象是适用的, 在许多情况下观察到, 确切的字是常见的 可能因上下文而异。 因此, 这种现象的特点是所谓的齐普夫定律。 这条法律规定一个词的等级 乘以这个词的频率是大致不变的。 所以, 如果我们正式地使用 F (w) 来表示频率, r (w) 表示一个词的等级。 然后这就是公式。 它基本上说的是一样的, 只是数学术语。 其中 C 基本上是一个常数, 然后这里也有一个参数, 阿尔法, 这可能会被调整, 以更好地适应任何经验观察。 所以如果我按排序的顺序绘制单词频率, 那么你就能更容易地看到这一点。 x 轴基本上是单词排名。 这是 r (w), y 轴是单词频率或 F (w)。 现在这条曲线表明, 两者的乘积大致是常数。 现在如果你看看这些词, 我们可以看到它们可以分成三组。 中间, 是中间频率词。 这些词倾向于在很多文件中出现 但是它们不用于最高频的那些词 它们也不是很低频的词 因此, 它们往往被用于 查询, 他们也倾向于有很高的 TF-IDF 重量。 这些中频词。 但如果你看一下曲线的左侧 这些是频率最高的单词。 它们出现的频率非常高。 它们经常是停用词，像the,we等等 这些话是非常, 非常频繁, 他们实际上是太频繁以至于 忽略，他们一般不是很有用的检索。 所以他们经常被删除, 这被称为停止字删除。 所以, 你可以使用几乎只是在集合中的那种词, 一种 推断什么词可能是停止的词。 这些基本上是频率最高的词。 而且它们在倒置指数中也占据了很大的空间。 你可以想象, 这样一个词的过帐条目会很长。 因此, 如果你能删除这些词, 你可以在倒置索引中节省大量的空间。 我们还展示了尾部部分, 其中有很多罕见的词。 这些词并不经常发生, 这样的词很多。 这些话实际上是非常有用的 如果用户恰好对这样的主题感兴趣, 也可以搜索。 但由于他们是罕见的, 它往往是真实的, 用户 不一定对这些词感兴趣。 但是, 保留它们将使我们能够准确地匹配这样一份文件。 他们的IDF一般都很高。 那么, 我们应该用什么样的数据结构来存储倒置索引呢？ 嗯, 它有两部分, 对吧。 如果你还记得, 我们有字典, 我们也有帖子。 字典有适度的大小, 虽然对于网络, 它仍然会是非常 大, 但比较它的张贴它是更小的 我们还需要有快速的随机访问的条目 因为我们想很快就找到查询项。 因此, 如果可能的话, 我们更愿意把这样的字典留在记忆中。 如果集合不是很大, 这是可行的, 但 如果集合非常大, 那么它一般是不可能的。 如果词汇量非常大, 显然我们做不到。 所以, 一般来说, 情况就是这样。 因此, 我们经常使用的数据结构 存储字典, 这将是直接访问。 有一些结构, 如哈希表, 或 如果我们不能将所有内容存储在内存中或使用磁盘, 则为 b 树。 然后尝试构建一个结构, 使其能够快速查找条目。 对于帖子来说, 它们是巨大的。 而一般来说, 我们不必直接访问特定的条目。 我们通常只会查找文档 Id 和 与查询项匹配的所有文档的频率。 因此, 将按顺序读取这些条目。 因此, 因为它很大, 我们通常有存储张贴光盘上, 他们必须留在光盘上, 他们将包含的信息, 如文档 Id, 长期频率或长期的位置, 等等。 现在, 因为他们是非常大的, 压缩往往是可取的。 现在, 这不仅是为了节省光盘空间, 这当然是 压缩的一个好处, 它不会占用那么大的空间。 但这也是为了帮助提高速度。 你知道为什么吗？ 嗯, 我们知道输入和输出会花费很多时间。 与 CPU 所花费的时间相比。 因此, CPU 速度要快得多, 但 IO 需要时间和 因此, 通过压缩倒置索引, posting文件将变得更小, 条目, 我们有读数, 和内存来处理一个查询项, 将是较小的, 然后, 所以我们可以减少 跟踪 IO 的数量, 这可以节省大量的时间。 当然, 我们必须做更多的数据处理时, 我们 解压缩内存中的数据。 但正如我所说, CPU 速度很快。 所以总之, 我们还能节省时间。 因此, 这里的压缩既是为了节省光盘空间, 也是为了节省光盘空间。 以加快索引的加载速度。 她们都有自己的孩子和孙子