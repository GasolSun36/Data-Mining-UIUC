1
00:00:00,076 --> 00:00:07,527
那么

2
00:00:07,527 --> 00:00:12,550
第二个降维方法是多维缩放

3
00:00:12,550 --> 00:00:16,110
该方法关注相关数据项的间的距离

4
00:00:16,110 --> 00:00:17,679
而不是它们的实际位置

5
00:00:18,760 --> 00:00:24,462
因此 多维缩放是
降维的一种方式

6
00:00:24,462 --> 00:00:28,269
我们之前了解了主成分分析法

7
00:00:28,269 --> 00:00:29,918
和降维方法的课程

8
00:00:29,918 --> 00:00:31,995
我们有高维数据

9
00:00:31,995 --> 00:00:34,911
并且要将其在低维显示

10
00:00:34,911 --> 00:00:39,895
即使是高维数据
使用大概两个或者三个坐标

11
00:00:39,895 --> 00:00:43,910
以便能够更好的以视觉感知数据

12
00:00:45,120 --> 00:00:49,651
我们从可视化图的角度讨论过

13
00:00:49,651 --> 00:00:54,609
视图对数据点之间的关系进行编码

14
00:00:54,609 --> 00:00:55,640
边长无关紧要。

15
00:00:55,640 --> 00:01:00,397
但是 如果我们要考虑一个视图
其边的长度是有意义的

16
00:01:00,397 --> 00:01:05,821
我们或许会要考虑一些方式
基于数据点之间的关系 基于距离

17
00:01:05,821 --> 00:01:11,357
来绘制一个图或者数据的节点

18
00:01:11,357 --> 00:01:15,002
以便可以在低维中仍保持距离 例如

19
00:01:15,002 --> 00:01:19,878
高维数据的一个二维可视化

20
00:01:19,878 --> 00:01:24,237
我们或许想用二维空间中
数据点之间的距离 以某种方式

21
00:01:24,237 --> 00:01:28,590
来标示出数据点间在更高维度中的距离

22
00:01:28,590 --> 00:01:30,741
于是设定一个 MDS 的指标

23
00:01:30,741 --> 00:01:36,166
用来测度在多维缩放中
将数据点显示在一个较低维的空间

24
00:01:36,166 --> 00:01:41,528
而仍试图保持数据点间的距离

25
00:01:41,528 --> 00:01:42,828
这里有一个很好的例子

26
00:01:42,828 --> 00:01:46,780
这里我们没有进行降维
因为我们是从二维空间

27
00:01:46,780 --> 00:01:48,401
到二维空间

28
00:01:48,401 --> 00:01:53,186
但是 它说明了如何计算多维缩放

29
00:01:53,186 --> 00:01:55,940
以尽量保持点之间的距离

30
00:01:55,940 --> 00:02:00,960
例如 这是美国城市间的距离

31
00:02:00,960 --> 00:02:08,510
我们有波士顿 纽约 哥伦比亚特区 迈阿密
芝加哥 西雅图 旧金山 洛杉矶 以及丹佛

32
00:02:08,510 --> 00:02:11,655
例如 在这个例子中
芝加哥和纽约的距离

33
00:02:11,655 --> 00:02:16,920
应该是803英里

34
00:02:16,920 --> 00:02:21,700
所以 该数据的下三角
显示的是每一行和每一列的城市

35
00:02:21,700 --> 00:02:26,740
它们之间的距离

36
00:02:26,740 --> 00:02:29,958
所以 一个城市到自己的距离是 0

37
00:02:29,958 --> 00:02:31,535
而且 这是对称的

38
00:02:31,535 --> 00:02:34,880
所以我没有费力去填写
这个矩阵的上三角

39
00:02:36,993 --> 00:02:42,512
那么根据这个距离 dij
第 i 和 j 个数据点之间的距离

40
00:02:42,512 --> 00:02:49,410
即第 i 和 j 个城市之间的距离
我们能否找回这些城市的位置 ?

41
00:02:49,410 --> 00:02:52,110
我没有用这些城市的坐标

42
00:02:52,110 --> 00:02:55,150
我只用这些城市间的距离

43
00:02:55,150 --> 00:03:00,118
基本上来说 是用一个图
来显示节点之间

44
00:03:00,118 --> 00:03:00,878
边的长度

45
00:03:00,878 --> 00:03:04,968
然后 我想要找到那些节点的位置

46
00:03:04,968 --> 00:03:06,380
其满足那些边的长度

47
00:03:06,380 --> 00:03:10,180
我们可以通过最小化这个函数做到

48
00:03:10,180 --> 00:03:16,430
基本上 我们使用两个数据点之间的距离

49
00:03:16,430 --> 00:03:21,080
然后 我们想要减去它们的实际距离
并且我们想要最小化这个差值

50
00:03:21,080 --> 00:03:25,050
于是 如果两个数据点间的距离

51
00:03:25,050 --> 00:03:28,800
等于这两点的期望的距离
那么这个函数应该接近于零

52
00:03:28,800 --> 00:03:32,483
然后 对这些取平方
以保证所有项都是正值

53
00:03:32,483 --> 00:03:36,031
从而最小化不受负值所影响

54
00:03:36,031 --> 00:03:40,048
我们能使用任何非线性优化方法
求解这个最小化问题

55
00:03:40,048 --> 00:03:44,985
在我将要描述的例子中
我求解最小化仅仅使用了

56
00:03:44,985 --> 00:03:50,170
Excel的一个优化插件

57
00:03:50,170 --> 00:03:52,830
这是我得到的运行结果

58
00:03:52,830 --> 00:03:57,421
我最小化了从被最优化的变量
到期望距离

59
00:03:57,421 --> 00:04:02,484
之间的距离关系

60
00:04:02,484 --> 00:04:06,664
如你所见 
这看起来明显不对

61
00:04:06,664 --> 00:04:10,246
我得到的是 东海岸在左边
而西海岸在东边

62
00:04:10,246 --> 00:04:12,410
但是 距离关系则是对的

63
00:04:12,410 --> 00:04:14,200
这里还有一些其它的不同之处

64
00:04:14,200 --> 00:04:19,420
但总的来说 我得到了这个
从东到西的基本趋势

65
00:04:19,420 --> 00:04:24,560
西雅图在旧金山和洛杉矶的上面
丹佛在这里 芝加哥在它该在的地方

66
00:04:24,560 --> 00:04:27,300
所以 我保持了那些点的距离

67
00:04:27,300 --> 00:04:31,398
即便我没能保持那些点的
绝对几何关系

68
00:04:31,398 --> 00:04:35,585
所以 这可以是一个有用的展示方法
特别是于对高维数据

69
00:04:35,585 --> 00:04:40,065
当你试图保持点之间的距离

70
00:04:40,065 --> 00:04:44,655
但不需要精确地表示它们的空间布局
即其原始坐标

71
00:04:44,655 --> 00:04:47,905
所以 我们扔掉了
这些点的原始坐标

72
00:04:47,905 --> 00:04:50,938
仅使用它们的距离关系

73
00:04:50,938 --> 00:04:55,848
试图在一个重新映射中保持它们的距离
如在这个二维空间的例子中

74
00:04:55,848 --> 00:05:00,004
有很多方式你可以使用 MDS（多维缩放）

75
00:05:00,004 --> 00:05:04,277
你可以可视化
数据点间相邻关系

76
00:05:04,277 --> 00:05:09,250
例如 基于文章的共同作者关系
确定的合作领域

77
00:05:09,250 --> 00:05:13,320
如果你在对论文
或者任何其它两个数据点

78
00:05:13,320 --> 00:05:17,980
可能共有的属性进行可视化
这些都可以通过距离关系来表达

79
00:05:17,980 --> 00:05:21,340
它不一定需要是坐标距离
它可以是其它相似的关系

80
00:05:21,340 --> 00:05:24,190
它被用在为用户界面设计的人机交互

81
00:05:24,190 --> 00:05:28,060
如基本的按钮位置摆放

82
00:05:28,060 --> 00:05:33,140
如果你一个仪表板 上面有很多按钮
你可以这样摆放按钮

83
00:05:33,140 --> 00:05:38,352
对给定任务来说
基于按钮有多相似来组织它们

84
00:05:38,352 --> 00:05:38,999
然后呢

85
00:05:38,999 --> 00:05:43,390
让多维缩放 计算出
按钮应该放在什么坐标位置

86
00:05:43,390 --> 00:05:48,050
从而让一起被使用的按钮
彼此摆放的很近

87
00:05:48,050 --> 00:05:52,980
它也被用在市场营销中
用来生成感知图（perceptual maps）

88
00:05:52,980 --> 00:05:57,420
该图是基于人们
对不同产品有什么想法

89
00:05:57,420 --> 00:06:01,140
给不同产品赋予什么属性
等的调查数据

90
00:06:01,140 --> 00:06:05,609
然后 你就可以弄明白
什么产品和其它产品相似

91
00:06:05,609 --> 00:06:07,711
并且用这种方法生成一个关于那些产品的视图

92
00:06:07,711 --> 00:06:11,660
所以 最优化使
多维缩放得以实现

93
00:06:11,660 --> 00:06:14,708
你不用自己去写你的优化程序

94
00:06:14,708 --> 00:06:17,511
你可以使用现有的
最优化软件包

95
00:06:17,511 --> 00:06:21,919
你只需要某个最小化一个函数的东西

96
00:06:21,919 --> 00:06:26,868
所以 你需要一个最优化软件包中
某种形式的非线性最小化

97
00:06:26,868 --> 00:06:31,214
我在Excel中找到了一个可用的
让我能展示

98
00:06:31,214 --> 00:06:34,716
我在幻灯片中讲述的例子

99
00:06:34,716 --> 00:06:43,753
[背景音乐]
翻译: RyukaSuu |审阅: 19waa
Coursera Global Translator Community